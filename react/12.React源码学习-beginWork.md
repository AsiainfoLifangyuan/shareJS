## beginWork

执行对整棵树的每一个节点进行更新的操作（performUnitOfWork内调用beginWork）

源码在 react-reconciler 下的 ReactFiberBeginWork.js 内：

`beginWork()`方法里通过 `switch (workInProgress.tag)`对不同的组件做不同的更新处理：

下面看看不同组件的更新：

#### 1.FunctionComponent

```
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps: any,
  renderExpirationTime,
) {
  // 此处去掉__DEV__代码
  const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
  const context = getMaskedContext(workInProgress, unmaskedContext);
  let nextChildren;
  prepareToReadContext(workInProgress, renderExpirationTime);
  prepareToUseHooks(current, workInProgress, renderExpirationTime);
  if (__DEV__) {
    // 此处去掉__DEV__代码
  } else {
    nextChildren = Component(nextProps, context);
  }
  nextChildren = finishHooks(Component, nextProps, nextChildren, context);
  // React DevTools reads this flag.
  workInProgress.effectTag |= PerformedWork;
  reconcileChildren(
    current,
    workInProgress,
    nextChildren,
    renderExpirationTime,
  );
  return workInProgress.child;
}
```
调用`Component`时传入了两个值`nextProps`和`context`, 那么函数组件可以直接通过第二个参数拿到`context`，官方文档没有说明过这点。

#### reconcileChildren

- 根据props.children生成Fiber子树
- 判断Fiber对象是否可以复用
- 列表根据key优化

```
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderExpirationTime: ExpirationTime,
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderExpirationTime,
    );
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderExpirationTime,
    );
  }
}
```
查看上面两种不同调用的方法引入:
```
import {
  mountChildFibers,
  reconcileChildFibers,
  cloneChildFibers,
} from './ReactChildFiber';
```
然后去ReactChildFiber.js内查看方法定义：
mountChildFibers和reconcileChildFibers方法是一样的，唯一的区别是生成这个方法的时候的一个参数不同
```
export const reconcileChildFibers = ChildReconciler(true);
export const mountChildFibers = ChildReconciler(false);
```
这个参数叫shouldTrackSideEffects，他的作用是判断是否要增加一些effectTag，主要是用来优化初次渲染的
```
if (shouldTrackSideEffects && newFiber.alternate === null) {
  newFiber.effectTag = Placement
}

```
ChildReconciler最终调用的是reconcileChildFibers:
```
function ChildReconciler(shouldTrackSideEffects) {
  // 省略其他代码
  function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null {}
  return reconcileChildFibers;
}
```
reconcileChildFibers会根据newChild的不同类型进行对应的处理，最终的返回是当前节点的第一个孩子节点，会在performUnitWork中 return 并赋值给nextUnitOfWork。

children的合法类型：

- ReactElement，通过createElement和ReactDOM.createPortal创建，$$typeof不同
- string或者number，<div>abc</div>中div的children就是"abc"
- [// renderAble]数组，每一项都可以是其他合法类型，不能嵌套
- Iterator，跟数组类似，只是遍历方式不同
- React.ConcurrentMode这些内置组件，最终会转换成ReactElement，不同的是ReactElement.type
- reconcileSingleElement & reconcileSinglePortal & reconcileSingleTextNode
- reconcileChildrenArray & reconcileChildrenArray