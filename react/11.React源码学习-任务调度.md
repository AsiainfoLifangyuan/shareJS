## 任务调度

任务调度图解：

![Event Loop](../assets/img/react_sc/fiber-scheduler.png)

源码在 react-reconciler 下的 ReactFiberScheduler.js 内：

##### scheduleWork:
```
function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
    // 更新Fiber及所有子树的expirationTime，
    // 返回FiberRoot
  const root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    // 去掉__DEV__代码
    return;
  }

  if (
    !isWorking &&
    nextRenderExpirationTime !== NoWork &&
    expirationTime > nextRenderExpirationTime
  ) {
    // This is an interruption. (Used for performance tracking.)
    interruptedBy = fiber;
    // 优先执行高优先级的任务
    resetStack();
  }
  markPendingPriorityLevel(root, expirationTime);
  if (
    // If we're in the render phase, we don't need to schedule this root
    // for an update, because we'll do it before we exit...
    !isWorking ||
    isCommitting ||
    // ...unless this is a different root than the one we're rendering.
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don't throw.
    // 防止更新中修改state,无限循环进入更新
    nestedUpdateCount = 0;
    invariant(
      false,
      'Maximum update depth exceeded. This can happen when a ' +
        'component repeatedly calls setState inside ' +
        'componentWillUpdate or componentDidUpdate. React limits ' +
        'the number of nested updates to prevent infinite loops.',
    );
  }
}
```

##### requestWork:

- 加入到root调度队列
- 判断是否批量更新
- 根据expirationTime判断调度类型

```
function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  // 处理firstScheduledRoot,lastScheduledRoot,root的expirationTime
  addRootToSchedule(root, expirationTime);
  if (isRendering) {
    // 已经开始
    return;
  }

  if (isBatchingUpdates) {
    // Flush work at the end of the batch.
    if (isUnbatchingUpdates) {
      // ...unless we're inside unbatchedUpdates, in which case we should
      // flush it now.
      nextFlushedRoot = root;
      nextFlushedExpirationTime = Sync;
      performWorkOnRoot(root, Sync, false);
    }
    return;
  }

  // TODO: Get rid of Sync and use current time?
  if (expirationTime === Sync) {
    performSyncWork();
  } else {
    scheduleCallbackWithExpirationTime(root, expirationTime);
  }
}
```